---
layout: post
title: No32 最长有效括号
category: LeetCode
tags: [动态规划]
description: 动态规划or栈
---
### 描述
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

##### 方法一：动态规划
这个问题可以通过动态规划解决。我们定义一个 dp 数组，其中第 i 个元素表示以下标为 i 的字符结尾的最长有效子字符串的长度。我们将 dp 数组全部初始化为 0 。现在，很明显有效的子字符串一定以 ‘)’ 结尾。这进一步可以得出结论：以 ‘(’ 结尾的子字符串对应的 dp 数组位置上的值必定为 0 。所以说我们只需要更新 ‘)’ 在 dp 数组中对应位置的值。

为了求出 dp 数组，我们每两个字符检查一次，如果满足如下条件

1. s[i] = ‘)’ 且 s[i - 1] = ‘(’ ，也就是字符串形如"……()"，我们可以推出：  
dp[i]=dp[i−2]+2  
我们可以进行这样的转移，是因为结束部分的 "()" 是一个有效子字符串，并且将之前有效子字符串的长度增加了 2 。
2. s[i] = ‘)’ 且 s[i - 1] = ‘)’，也就是字符串形如 ".......))" ，我们可以推出：  
如果 s[i - dp[i - 1] - 1] = ‘(’ ，那么dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2



##### 方法二：栈
与找到每个可能的子字符串后再判断它的有效性不同，我们可以用栈在遍历给定字符串的过程中去判断到目前为止扫描的子字符串的有效性，同时能的都最长有效字符串的长度。我们首先将 -1−1 放入栈顶。

对于遇到的每个 ‘(’ ，我们将它的下标放入栈中。
对于遇到的每个 ‘)’ ，我们弹出栈顶的元素并将当前元素的下标与弹出元素下标作差，得出当前有效括号字符串的长度。通过这种方法，我们继续计算有效子字符串的长度，并最终返回最长有效子字符串的长度。

    public class Solution {

        public int longestValidParentheses(String s) {
            int maxans = 0;
            Stack<Integer> stack = new Stack<>();
            stack.push(-1);
            for (int i = 0; i < s.length(); i++) {
                if (s.charAt(i) == '(') {
                    stack.push(i);
                } else {
                    stack.pop();
                    if (stack.empty()) {
                        stack.push(i); //关键：处理（）））））（的情况
                    } else {
                        maxans = Math.max(maxans, i - stack.peek());
                    }
                }
            }
            return maxans;
        }
    }
